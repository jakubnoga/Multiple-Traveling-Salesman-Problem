\documentclass[11pt]{article}
\usepackage[OT4]{polski}
\usepackage[cp1250]{inputenc} 
\usepackage{mathtools}
\usepackage{listings}
\usepackage{color}
\usepackage{enumerate}
\usepackage{graphicx}
\numberwithin{equation}{subsection}
\definecolor{mygreen}{rgb}{0,0.6,0}
\lstset{
  basicstyle=\fontsize{8}{10}\selectfont\ttfamily,
  tabsize = 2,
  commentstyle=\color{mygreen},
  language=Java
}

\begin{document}
\title{Multiple Traveling Salesmen Problem}
\author{Marcin Juraszek \\ Jakub Noga}
\maketitle
	\section{Wstêp}
		\subsection{Opis problemu}
		Problem wielu komiwoja¿erów (MTSP) jest odmian¹ szeroko znanego problemu
		komiwoja¿era (TSP). Problem charakteryzuje siê wiêksz¹ z³o¿onoœci¹ (wiêksza
		liczba rozwi¹zañ dopuszczalnych), natomiast nie powoduje to zwiêkszenia
		trudnoœci w jego matematycznym modelowaniu. 
		\newline
		\newline
		Istnienie problemu wielu komiwoja¿erów mo¿emy zaobserwowaæ na przyk³ad w
		logistyce, kiedy to dysponuj¹c ograniczon¹ flot¹ pojazdów i kierowców (w
		odró¿nieniu do TSP, gdzie dysponujemy dok³adnie jednym) chcemy dostaæ siê do
		wielu miejscowoœci ponosz¹c mo¿liwie najni¿sze, zdefiniowane przez nas koszty.
		
		\subsection{Podejœcie do problemu}
		Zdecydowaliœmy, ¿e przyst¹pimy do rozwa¿añ nad problemem sprowadzaj¹c go do
		klasycznego problemu jednego komiwoja¿era, stosuj¹c jedynie drobn¹
		modyfikacjê: miasto - $baza$ mo¿e zostaæ osi¹gniête wielokrotnie. Spowoduje
		to powstanie opartych na nim podcykli, które, równowa¿nie, mo¿na traktowaæ
		jako zakoñczenie trasy jednego, a rozpoczêcie drugiego komiwoja¿era.
	
	\section{Model matematyczny}
		\subsection{Struktura danych}
		Do przedstawienia danych problemu w jêzyku pos³u¿yliœmy siê macierzami oraz, w
		niektórych przypadkach, wektorami.
		\newline
		\newline		
		Podstawowe dane na temat konkretnej
		instancji problemu tj. koszty przejœæ pomiêdzy kolejnymi miastami
		przedstawiliœmy w postaci macierzy kosztów $n \times n$:
		$$
				C = \begin{bmatrix} 0 & c_{01} & c_{02} & \hdots & c_{0n} \\ 
				c_{10} & 0 & c_{12} & \hdots & c_{1n} \\
				\vdots & & \ddots & & \vdots \\
				c_{n0} & & \hdots & & 0
		\end{bmatrix}
		$$ 
		\newline
		Gdzie $c_{ij}$ to koszt przejœcia pomiêdzy miastem $i$ a $j$.
		\newline
		\newline
		Do przechowania rozwi¹zañ skorzystaliœmy z dwóch równowa¿nych postaci zapisu
		sekwencji przejœæ z miasta do miasta: macierzy przejœæ $X$ oraz wektora $r$.
		Gdzie: $$X = [X_{ij}] \in \{0,1\}$$ oraz $$ r = [0,r_0,\ldots,r_m, 0]
		:
		r_k \in \{0, \ldots, n\}$$
		\newline
		\newline
		Na przyk³ad macierz: 
		$$X = \begin{bmatrix} 0 & 1 & 0 & 1 & 0 \\
							  0 & 0 & 1 & 0 & 0 \\
							  0 & 0 & 0 & 1 & 0 \\
							  1 & 0 & 0 & 0 & 0 \\
							  1 & 0 & 0 & 0 & 0
		\end{bmatrix}
		$$
		Odpowiada wektorowi: $$r = [0,1,2,3,0,4,0]$$
		\newpage
		\subsection{Model}
		Problem wielu komiwoja¿erów mo¿na przedstawiæ jako nastêpuj¹cy problem
		programowania ca³kowito-liczbowego:
		\newline
		\newline
		$X$ - macierz przejœæ
		\newline
		$C$ - macierz kosztów
		\newline
		$n$ - rozmiar problemu (iloœæ miast)
		\newline
		$m$ - iloœæ komiwoja¿erów
		\newline
		$c_m$ - koszt wys³ania jednego komiwoja¿era
		\begin{equation}
		F(X) = \sum\limits_{i=0}^n\sum\limits_{j=0}^n(C_{ij}X_{ij} + mc_m)\rightarrow
		min 
		\end{equation} 
		\begin{equation}
		0 \leq \sum\limits_{j=1}^n X_{0j}=\sum\limits_{i=1}^n X_{i0} \leq m 
		\end{equation} 
		\begin{equation}
		\sum\limits_{i=1}^nX_{ij} = 1 : j=1,\ldots,n
		\end{equation}
		\begin{equation} 
		\sum\limits_{j=1}^nX_{ij} = 1 : i=1,\ldots,n
		\end{equation} 
	\newpage
	\section{Adaptacja algorytmu pszczelego}
		\subsection{Przebieg pracy algorytmu}
		\subsubsection{Scouting}
		Scouting - wys³anie pszczó³ zwiadowców, polega na wygenerowaniu zbioru
		losowych rozwi¹zañ dopuszczalnych. Klasa $ScoutBee$ posiada metodê:
		\begin{lstlisting}
public int[][] call() throws Exception {
	int [][]transitionMatrix = new int[dimensions][dimensions];
	while(!allTownsVisited()){ 
		int nextTown = -1; int currentTown = stepOutOfDepot();
		transitionMatrix[0][currentTown] = 1;
		visitedTowns.put(currentTown, true);
		while(!allTownsVisited()){
			nextTown = takeStep();
			if(nextTown == 0){					
				break;
			} else {
				transitionMatrix[currentTown][nextTown] = 1;
				visitedTowns.put(nextTown, true);
			}
			currentTown = nextTown;
		}
		transitionMatrix[currentTown][0] = 1;
	}		
	return transitionMatrix;
}
		\end{lstlisting}
		Metoda ta budujê losow¹ macierz przejœæ w nastêpuj¹cy sposób:
		\begin{enumerate}[(1)]
		  \item Je¿eli nie odwiedzono jeszcze wszystkich miast, wylosuj, do
		  którego wyjœæ z bazy.
		  \item Dopóki nie odwiedzono wszystkich miast losuj kolejne miasto do momentu
		  powrotu do bazy.
		  \item Wróæ do pkt. 1.
		\end{enumerate}
		Ka¿da pszczo³a-zwiadowca zwraca jedn¹ losow¹ macierz przejœæ. Iloœæ
		pszczó³-zwiadowców ustalana jest przez u¿ytkownika.
		\subsubsection{Wybór s¹siedztw elitarnych}
		Za s¹siedztwa elitarne uwa¿amy zbiór rozwi¹zañ (licznoœæ - $l$ tego zbioru
		jest okreœlana przez u¿ytkownika), które charakteryzuj¹ siê najwy¿sz¹ wartoœci¹
		funkcji celu. Przypisanie odbywa siê poprzez sortowanie malej¹ce listy
		rozwi¹zñ losowych wybranych w pierwszym etapie dzia³ania algorytmu, a
		nastêpnie wybór pierwszych $l$ obiektów z listy.
		\subsubsection{Eksploracja s¹siedztw elitarnych}
		Na tym etapie algorytm korzysta z postaci równowa¿nej do macierzy przejœæ - X,
		czyli wektora przejœæ - r.
		\newline
		\newline
		Eksploracja s¹siedztw elitarnych polega na losowej zmianie kolejnoœci na $n$
		kolejnych pozycjach wektora, liczba $n$ zmienia siê proporcjonalnie
		do liczby pozosta³ych iteracji w nastêpuj¹cy sposób: 
		\begin{equation} 
			n = WartoscPoczatkowa *
			\frac{LiczbaIteracji-AktualnaIteracja}{LiczbaIteracji}
		\end{equation} 
		$WartoscPoczatkowa$ - jest parametrem podawanym przez u¿ytkownika.
		Ka¿de z s¹siedztw elitarnych eksplorowane jest przez $w$ pszczó³-robotnic -
		liczba $w$ ustalana jest przez u¿ytkownika.
		\newline
		\newline
		Przyk³ad:
		\newline
		Dla s¹siedztwa elitarnego o reprezentacji w postaci wektora\newline $r_{0} =
		[0,9,8,7,6,0,1,3,2,0,4,5,0]$, oraz dla $n=5$, przyk³adowym rozwi¹zaniem
		zwróconym przez funkcjê eksploracji s¹siedztw elitarnych mo¿e byæ $r_{1} =
		[0,9,8,7,0,6,2,1,3,0,4,5,0]$. Permutacja mia³a miejsce od 5. do 10. miejsca w
		wektorze.
		
		\subsubsection{Iteracje}
		Iloœæ iteracji ustalana jest przez u¿ytkownika. Podczas ka¿dej itaracji
		powstaje $l \cdot w$ s¹siedztw dlatego wysoce niewydajnym, pod wzglêdem
		pamiêci operacyjnej, jest przechowywanie wszystkich wyników. Z tego powodu, co
		ustalon¹ liczbê iteracji $i$ nastêpuje ponowny wybór s¹siedztw elitarnych spoœród
		s¹siedztw powsta³ych z eksploracji. Po tej operacji algorytm kontynuuje
		standardow¹ eksploracjê.
		\subsubsection{Zbiór parametrów algorytmu}
		\begin{itemize}
		  \item s - liczba pszczó³-zwiadowców - oznacza iloœæ pocz¹tkowych rozwi¹zañ
		  losowych
		  \item l - liczba s¹siedztw elitarnych - oznacza iloœæ modyfikowanych
		  rozwi¹zañ w czasie ka¿dej iteracji, w celu polepszenia wartoœci funkcji celu
		  \item w - liczba pszczó³-robotnic przypadaj¹ca na jedno s¹siedztwo elitarne
		  - oznacza iloœæ nowych rozwi¹zañ powsta³ych z ka¿dego s¹siedztwa elitarnego
		  \item n - iloœæ elementów wektora przejœæ, które bêd¹ permutowane (wielkoœæ
		  s¹siedztwa) - mówi w jakim stopniu nowe rozwi¹zanie bêdzie ró¿ni³o siê od
		  s¹siedztwa elitarnego, z którego siê wywodzi.
		  \item i - liczba iteracji, po których s¹siedztwa elitarne zostan¹ przypisane
		  na nowo - mówi o tym jak czêsto rozwi¹zania, które powsta³y poprzez
		  permutacjê s¹siedztw elitarnych i poprawi³y wartoœæ funkcji celu, bêd¹
		  przejmowa³y rolê s¹siedztw elitarnych. 
		  \item t - iloœæ iteracji algorytmu
		\end{itemize}
	
	\section{Interfejs u¿ytkownika}
	\subsection{Aplikacja Webowa}
	\subsubsection{Wybór miejsc na mapie}
	\subsubsection{Instancja testowa TSPLib}
	
\end{document}